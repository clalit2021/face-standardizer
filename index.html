<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Face Standardizer — Beauty Spot Clinic</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet" />
<style>
  @keyframes slide { 0% { transform: translateX(-200%); } 100% { transform: translateX(450%); } }
  @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
  * { box-sizing: border-box; margin: 0; }
  body { margin: 0; background: #111010; }
  button:hover { opacity: 0.88; }
  button:active { transform: scale(0.98) !important; }
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-thumb { background: rgba(200,169,126,0.2); border-radius: 3px; }
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useRef, useCallback, useEffect } = React;

// Constants
const OUTPUT_SIZE = 512;
const EYE_Y_RATIO = 0.38;
const INTER_EYE_RATIO = 0.32;
const CHIN_Y_RATIO = 0.78;
const EYE_WEIGHT = 0.6;
const CHIN_WEIGHT = 1 - EYE_WEIGHT;
const DETECT_TIMEOUT_MS = 8000;
const PREVIEW_MAX = 420;

const LEFT_EYE_INDICES = [33, 133, 160, 159, 158, 144, 145, 153];
const RIGHT_EYE_INDICES = [362, 263, 387, 386, 385, 373, 374, 380];
const CHIN_INDEX = 152;

const StatusBadge = ({ status }) => {
  const configs = {
    detecting: { bg: "rgba(78,205,196,0.15)", color: "#4ecdc4", border: "rgba(78,205,196,0.3)", text: "⟳ Detecting face...", anim: true },
    success: { bg: "rgba(78,205,196,0.12)", color: "#4ecdc4", border: "rgba(78,205,196,0.25)", text: "✓ Face detected automatically" },
    failed: { bg: "rgba(255,107,107,0.12)", color: "#ff6b6b", border: "rgba(255,107,107,0.25)", text: "✗ No face detected — try manual" },
    manual: { bg: "rgba(200,169,126,0.12)", color: "#c8a97e", border: "rgba(200,169,126,0.25)", text: "◎ Manual landmarks placed" },
  };
  const c = configs[status];
  if (!c) return null;
  return (
    <div style={{ background: c.bg, color: c.color, border: `1px solid ${c.border}`, borderRadius: 8, padding: "6px 12px", fontSize: 12, fontWeight: 500, display: "flex", alignItems: "center", gap: 6, marginTop: 8, animation: c.anim ? "pulse 1.5s ease-in-out infinite" : "none" }}>
      {c.text}
    </div>
  );
};

const UploadIcon = () => (
  <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.2" strokeLinecap="round">
    <rect x="3" y="3" width="18" height="18" rx="3" />
    <circle cx="8.5" cy="8.5" r="1.5" />
    <path d="m21 15-5-5L5 21" />
  </svg>
);

const SlotPanel = ({
  slot, label, image, result, detectionStatus, isManual, activeSlot,
  hasLandmarks, processing, modelReady, outputSize, stepLabel,
  onReset, onDrop, onRetry, onManualStart, onDownload, onFlip,
  fileRef, previewRef, canvasRef, onCanvasClick,
  ghostImage, slotWarnings,
}) => (
  <div style={S.panel}>
    <div style={S.panelHead}>
      <span style={S.panelLabel}>{label}</span>
      {image && <button onClick={() => onReset(slot)} style={S.resetBtn}>✕</button>}
    </div>
    {!image ? (
      <div
        style={S.dropzone}
        onDragOver={(e) => e.preventDefault()}
        onDrop={(e) => onDrop(slot, e)}
        onClick={() => fileRef.current?.click()}
      >
        <input
          ref={fileRef}
          type="file"
          accept="image/*"
          style={{ display: "none" }}
          onChange={(e) => onDrop(slot, { preventDefault: () => {}, stopPropagation: () => {}, target: e.target })}
        />
        <div style={{ color: "#3a3530", marginBottom: 12 }}><UploadIcon /></div>
        <p style={{ color: "#6a5f52", fontSize: 13, fontWeight: 500 }}>Drop {label.toLowerCase()} photo</p>
        <p style={{ color: "#3a3530", fontSize: 11, marginTop: 3 }}>or click to browse</p>
      </div>
    ) : (
      <div style={{ padding: 14 }}>
        <div style={S.previewContainer}>
          <canvas
            ref={previewRef}
            style={{ ...S.previewCanvas, cursor: isManual ? "crosshair" : "default" }}
            onClick={(e) => onCanvasClick(slot, e)}
          />
          {isManual && ghostImage && (
            <div style={S.ghostOverlay}>
              <img src={ghostImage} alt="alignment ghost" style={S.ghostImg} />
              <span style={S.ghostLabel}>Ghost overlay active</span>
            </div>
          )}
          {isManual && activeSlot === slot && (
            <div style={S.stepBadge}>{stepLabel}</div>
          )}
        </div>
        <StatusBadge status={detectionStatus} />
        {slotWarnings && slotWarnings.length > 0 && (
          <div style={S.warningsBox}>
            {slotWarnings.map((w, i) => (
              <div key={i} style={S.warningItem}>⚠ {w}</div>
            ))}
          </div>
        )}
        <div style={S.actionRow}>
          {image && (
            <button onClick={() => onFlip(slot)} style={S.actionBtn} disabled={processing} title="Flip horizontal (fix selfie mirror)">
              ↔ Flip
            </button>
          )}
          {detectionStatus === "failed" && (
            <button onClick={() => onRetry(slot)} style={S.actionBtn} disabled={processing || !modelReady}>
              ⟳ Retry
            </button>
          )}
          <button
            onClick={() => onManualStart(slot)}
            style={{
              ...S.actionBtn,
              ...(detectionStatus === "failed"
                ? { background: "rgba(200,169,126,0.12)", color: "#c8a97e", borderColor: "rgba(200,169,126,0.3)" }
                : {}),
            }}
            disabled={processing}
          >
            {hasLandmarks ? "✎ Re-mark" : "◎ Manual"}
          </button>
        </div>
        {result && (
          <div style={{ marginTop: 16, textAlign: "center", paddingTop: 14, borderTop: "1px solid rgba(200,169,126,0.06)" }}>
            <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 10, padding: "0 4px" }}>
              <span style={{ fontSize: 10, textTransform: "uppercase", letterSpacing: "1.5px", color: "#6a5f52", fontWeight: 600 }}>Output</span>
              <span style={{ fontSize: 10, color: "#3a3530", fontFamily: "monospace" }}>{outputSize}×{outputSize}</span>
            </div>
            <img src={result} alt={`${label} result`} style={S.resultImg} />
            <button onClick={() => onDownload(slot)} style={S.dlBtn}>↓ Download</button>
          </div>
        )}
      </div>
    )}
    <canvas ref={canvasRef} style={{ display: "none" }} />
  </div>
);

const CompLabel = ({ text, right, style: extraStyle }) => (
  <span style={{
    position: "absolute", bottom: 12, [right ? "right" : "left"]: 12,
    background: "rgba(0,0,0,0.6)", color: "white", padding: "4px 8px",
    borderRadius: 4, fontSize: 10, fontWeight: 700, letterSpacing: 1, pointerEvents: "none",
    ...extraStyle
  }}>
    {text}
  </span>
);

const AdvancedComparison = ({ before, after, onDownload }) => {
  const [mode, setMode] = useState("wipe");
  const [sliderPos, setSliderPos] = useState(50);
  const [isAnimating, setIsAnimating] = useState(false);
  const containerRef = useRef(null);

  useEffect(() => {
    let animId;
    let direction = 1;
    if (isAnimating) {
      const animate = () => {
        setSliderPos((prev) => {
          let next = prev + 0.5 * direction;
          if (next >= 100 || next <= 0) {
            direction *= -1;
            next = Math.max(0, Math.min(100, next));
          }
          return next;
        });
        animId = requestAnimationFrame(animate);
      };
      animId = requestAnimationFrame(animate);
    }
    return () => cancelAnimationFrame(animId);
  }, [isAnimating]);

  const handleDrag = (e) => {
    if (!containerRef.current || mode === "side") return;
    const rect = containerRef.current.getBoundingClientRect();
    const x = e.touches ? e.touches[0].clientX : e.clientX;
    const pos = ((x - rect.left) / rect.width) * 100;
    setSliderPos(Math.max(0, Math.min(100, pos)));
  };

  return (
    <div style={{ maxWidth: 800, margin: "20px auto", userSelect: "none", position: "relative", zIndex: 1, padding: "0 28px" }}>
      <div style={{ display: "flex", justifyContent: "center", gap: 8, marginBottom: 16 }}>
        {[
          { id: "wipe", label: "↔ Wipe", icon: "◫" },
          { id: "fade", label: "✨ Fade", icon: "◐" },
          { id: "side", label: "Side-by-Side", icon: "⚏" },
        ].map((m) => (
          <button
            key={m.id}
            onClick={() => { setMode(m.id); setIsAnimating(false); setSliderPos(50); }}
            style={{
              padding: "8px 16px", borderRadius: 20,
              border: "1px solid rgba(200,169,126,0.2)",
              background: mode === m.id ? "rgba(200,169,126,0.2)" : "transparent",
              color: mode === m.id ? "#c8a97e" : "#6a5f52",
              fontSize: 12, fontWeight: 600, cursor: "pointer", display: "flex", alignItems: "center", gap: 6
            }}
          >
            <span>{m.icon}</span> {m.label}
          </button>
        ))}
      </div>

      <div
        ref={containerRef}
        style={{
          position: "relative",
          aspectRatio: mode === "side" ? "2/1" : "1/1",
          width: "100%", borderRadius: 12, overflow: "hidden",
          border: "1px solid rgba(200,169,126,0.15)",
          cursor: mode === "side" ? "default" : "ew-resize",
          touchAction: "none"
        }}
        onMouseDown={(e) => { if (mode !== "side") handleDrag(e); }}
        onMouseMove={(e) => { if (e.buttons === 1 && mode !== "side") handleDrag(e); }}
        onTouchMove={(e) => { if (mode !== "side") handleDrag(e); }}
      >
        {mode === "side" && (
          <div style={{ display: "flex", width: "100%", height: "100%" }}>
            <div style={{ flex: 1, position: "relative", borderRight: "1px solid #000" }}>
              <img src={before} style={{ width: "100%", height: "100%", objectFit: "cover" }} />
              <CompLabel text="BEFORE" />
            </div>
            <div style={{ flex: 1, position: "relative" }}>
              <img src={after} style={{ width: "100%", height: "100%", objectFit: "cover" }} />
              <CompLabel text="AFTER" />
            </div>
          </div>
        )}

        {mode === "fade" && (
          <div style={{ width: "100%", height: "100%", position: "relative" }}>
            <img src={before} style={{ position: "absolute", width: "100%", height: "100%", objectFit: "cover" }} />
            <img src={after} style={{ position: "absolute", width: "100%", height: "100%", objectFit: "cover", opacity: sliderPos / 100 }} />
            <CompLabel text="BEFORE" style={{ opacity: 1 - sliderPos / 100 }} />
            <CompLabel text="AFTER" right style={{ opacity: sliderPos / 100 }} />
          </div>
        )}

        {mode === "wipe" && (
          <div style={{ width: "100%", height: "100%", position: "relative" }}>
            <img src={after} style={{ width: "100%", height: "100%", objectFit: "cover" }} />
            <div style={{ position: "absolute", top: 0, left: 0, width: `${sliderPos}%`, height: "100%", overflow: "hidden", borderRight: "1px solid rgba(255,255,255,0.8)" }}>
              <img src={before} style={{ width: "100%", height: "100%", objectFit: "cover" }} />
            </div>
            <CompLabel text="BEFORE" />
            <CompLabel text="AFTER" right />
            <div style={{
              position: "absolute", bottom: 0, left: `${sliderPos}%`, transform: "translateX(-50%)",
              width: 24, height: 24, background: "#c8a97e", borderRadius: "4px 4px 0 0",
              display: "flex", alignItems: "center", justifyContent: "center",
              boxShadow: "0 -2px 10px rgba(0,0,0,0.3)"
            }}>
              <div style={{ width: 2, height: 12, background: "#1a1714", borderRadius: 1 }} />
            </div>
          </div>
        )}
      </div>

      <div style={{ display: "flex", justifyContent: "space-between", marginTop: 16 }}>
        {mode !== "side" && (
          <button
            onClick={() => setIsAnimating(!isAnimating)}
            style={{
              background: "none", border: "1px solid rgba(200,169,126,0.3)", color: "#c8a97e",
              borderRadius: 8, padding: "8px 16px", fontSize: 12, cursor: "pointer"
            }}
          >
            {isAnimating ? "⏸ Stop Glide" : "▶ Auto-Glide"}
          </button>
        )}
        <button
          onClick={onDownload}
          style={{
            background: "linear-gradient(135deg, #c8a97e, #a8895e)", border: "none", color: "#1a1714",
            borderRadius: 8, padding: "8px 24px", fontSize: 12, fontWeight: 700, cursor: "pointer",
            marginLeft: "auto"
          }}
        >
          ↓ Download Composite
        </button>
      </div>
    </div>
  );
};

class AsyncMutex {
  constructor() { this._queue = []; this._locked = false; }
  async acquire() {
    if (!this._locked) { this._locked = true; return; }
    return new Promise((resolve) => this._queue.push(resolve));
  }
  release() {
    if (this._queue.length > 0) {
      const next = this._queue.shift();
      next();
    } else {
      this._locked = false;
    }
  }
}

const getEyeCenter = (fl, indices, w, h) => {
  let x = 0, y = 0;
  indices.forEach((i) => { x += fl[i].x * w; y += fl[i].y * h; });
  return { x: x / indices.length, y: y / indices.length };
};

const previewScale = (img) => Math.min(PREVIEW_MAX / img.width, PREVIEW_MAX / img.height);

const scaleToPreview = (lm, s) => ({
  leftEye: { x: lm.leftEye.x * s, y: lm.leftEye.y * s },
  rightEye: { x: lm.rightEye.x * s, y: lm.rightEye.y * s },
  chin: { x: lm.chin.x * s, y: lm.chin.y * s },
});

const scaleFromPreview = (lm, s) => ({
  leftEye: { x: lm.leftEye.x / s, y: lm.leftEye.y / s },
  rightEye: { x: lm.rightEye.x / s, y: lm.rightEye.y / s },
  chin: { x: lm.chin.x / s, y: lm.chin.y / s },
});

const loadImage = async (file) => {
  if (typeof createImageBitmap === "function") {
    try {
      const bitmap = await createImageBitmap(file, { imageOrientation: "from-image" });
      const c = document.createElement("canvas");
      c.width = bitmap.width;
      c.height = bitmap.height;
      c.getContext("2d").drawImage(bitmap, 0, 0);
      bitmap.close();
      const blob = await new Promise((res) => c.toBlob(res, "image/png"));
      const url = URL.createObjectURL(blob);
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
        img.onerror = () => { URL.revokeObjectURL(url); reject(); };
        img.src = url;
      });
    } catch(e) { /* fall through */ }
  }
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });
};

const FaceStandardizer = () => {
  const [images, setImages] = useState({ before: null, after: null });
  const [results, setResults] = useState({ before: null, after: null });
  const [landmarks, setLandmarks] = useState({ before: null, after: null });
  const [detectionStatus, setDetectionStatus] = useState({ before: null, after: null });
  const [manualMode, setManualMode] = useState({ before: false, after: false });
  const [clickStep, setClickStep] = useState(null);
  const [activeSlot, setActiveSlot] = useState(null);
  const [processing, setProcessing] = useState(false);
  const [modelLoading, setModelLoading] = useState(false);
  const [modelReady, setModelReady] = useState(false);
  const [outputSize, setOutputSize] = useState(OUTPUT_SIZE);
  const [bgColor, setBgColor] = useState("#f0ece4");
  const [showGuides, setShowGuides] = useState(true);
  const [exportFormat, setExportFormat] = useState("png");
  const [compareMode, setCompareMode] = useState(false);
  const [autoDetect, setAutoDetect] = useState(true);
  const [scaleMode, setScaleMode] = useState("aesthetic");
  const [lockFraming, setLockFraming] = useState(true);
  const [warnings, setWarnings] = useState({ before: [], after: [] });

  const tempPointsRef = useRef({});
  const [tempPointsVer, setTempPointsVer] = useState(0);
  const objectUrlsRef = useRef({ before: null, after: null });
  const beforeFramingRef = useRef(null); // stores { targetInterEyePixels } from Before for lock mode
  const canvasRefs = { before: useRef(null), after: useRef(null) };
  const previewRefs = { before: useRef(null), after: useRef(null) };
  const imgRefs = { before: useRef(null), after: useRef(null) };
  const fileRefs = { before: useRef(null), after: useRef(null) };
  const faceMeshRef = useRef(null);
  const pendingResolverRef = useRef(null);
  const mutexRef = useRef(new AsyncMutex());

  useEffect(() => {
    return () => {
      if (objectUrlsRef.current.before) URL.revokeObjectURL(objectUrlsRef.current.before);
      if (objectUrlsRef.current.after) URL.revokeObjectURL(objectUrlsRef.current.after);
    };
  }, []);

  useEffect(() => {
    let cancelled = false;
    const load = async () => {
      setModelLoading(true);
      try {
        const loadScript = (src) =>
          new Promise((resolve, reject) => {
            if (document.querySelector(`script[src="${src}"]`)) { resolve(); return; }
            const s = document.createElement("script");
            s.src = src;
            s.onload = resolve;
            s.onerror = reject;
            document.head.appendChild(s);
          });
        await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js");
        await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js");
        await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js");
        if (cancelled) return;

        const fm = new window.FaceMesh({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`,
        });
        fm.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        fm.onResults((res) => {
          const r = pendingResolverRef.current;
          if (!r) return;
          pendingResolverRef.current = null;
          if (res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0) {
            r.resolve(res.multiFaceLandmarks[0]);
          } else {
            r.resolve(null);
          }
        });

        faceMeshRef.current = fm;
        if (!cancelled) setModelReady(true);
      } catch (err) {
        console.error("MediaPipe load error:", err);
      }
      if (!cancelled) setModelLoading(false);
    };
    load();
    return () => { cancelled = true; };
  }, []);

  const detectFace = useCallback(async (img) => {
    if (!modelReady || !faceMeshRef.current) return null;
    const mutex = mutexRef.current;
    await mutex.acquire();
    try {
      const tc = document.createElement("canvas");
      tc.width = img.width;
      tc.height = img.height;
      tc.getContext("2d").drawImage(img, 0, 0);

      return await new Promise((resolve) => {
        const timeout = setTimeout(() => {
          if (pendingResolverRef.current) {
            console.warn("detectFace: timed out");
            pendingResolverRef.current = null;
            resolve(null);
          }
        }, DETECT_TIMEOUT_MS);

        pendingResolverRef.current = {
          resolve: (fl) => {
            clearTimeout(timeout);
            if (!fl) { resolve(null); return; }
            resolve({
              leftEye: getEyeCenter(fl, LEFT_EYE_INDICES, img.width, img.height),
              rightEye: getEyeCenter(fl, RIGHT_EYE_INDICES, img.width, img.height),
              chin: { x: fl[CHIN_INDEX].x * img.width, y: fl[CHIN_INDEX].y * img.height },
            });
          },
        };
        faceMeshRef.current.send({ image: tc });
      });
    } finally {
      mutex.release();
    }
  }, [modelReady]);

  const processImageFromOriginal = useCallback((slot, lm, img) => {
    const sz = outputSize;
    const canvas = canvasRefs[slot].current;
    if (!canvas || !img || !lm) return;
    const ctx = canvas.getContext("2d");
    canvas.width = sz;
    canvas.height = sz;

    const eyeCX = (lm.leftEye.x + lm.rightEye.x) / 2;
    const eyeCY = (lm.leftEye.y + lm.rightEye.y) / 2;
    const dx = lm.rightEye.x - lm.leftEye.x;
    const dy = lm.rightEye.y - lm.leftEye.y;
    let angle = Math.atan2(dy, dx);
    if (Math.abs(angle) > Math.PI / 2) {
      angle = angle > 0 ? angle - Math.PI : angle + Math.PI;
    }

    const interEyeDist = Math.sqrt(dx * dx + dy * dy);
    if (interEyeDist < 5) {
      console.warn("processImage: eye landmarks too close, skipping");
      return;
    }
    const scaleFromEyes = (sz * INTER_EYE_RATIO) / interEyeDist;

    const slotWarnings = [];
    const tiltDeg = Math.abs(angle) * (180 / Math.PI);
    if (tiltDeg > 15) slotWarnings.push(`Head tilt ${tiltDeg.toFixed(0)}° — consider retaking`);
    if (interEyeDist < 30) slotWarnings.push("Face very small — move camera closer");
    try {
      const sampCanvas = document.createElement("canvas");
      const sW = Math.min(img.width, 200);
      const sH = Math.min(img.height, 200);
      sampCanvas.width = sW;
      sampCanvas.height = sH;
      const sCtx = sampCanvas.getContext("2d");
      sCtx.drawImage(img, (img.width - sW) / 2, (img.height - sH) / 2, sW, sH, 0, 0, sW, sH);
      const pix = sCtx.getImageData(0, 0, sW, sH).data;
      let sum = 0;
      for (let i = 0; i < pix.length; i += 16) sum += pix[i] * 0.299 + pix[i + 1] * 0.587 + pix[i + 2] * 0.114;
      const avgBrightness = sum / (pix.length / 16);
      if (avgBrightness < 50) slotWarnings.push("Image appears dark — check lighting");
      if (avgBrightness > 240) slotWarnings.push("Image appears overexposed");
    } catch(e) { /* sampling failed, skip */ }
    setWarnings((prev) => ({ ...prev, [slot]: slotWarnings }));

    let scale;
    if (scaleMode === "strict") {
      scale = scaleFromEyes;
    } else {
      const chinDx = lm.chin.x - eyeCX;
      const chinDy = lm.chin.y - eyeCY;
      const eyeToChinDist = Math.abs(-chinDx * Math.sin(angle) + chinDy * Math.cos(angle));
      const desiredChinDist = sz * (CHIN_Y_RATIO - EYE_Y_RATIO);
      const scaleFromChin = eyeToChinDist > 0 ? desiredChinDist / eyeToChinDist : scaleFromEyes;
      const blended = EYE_WEIGHT * scaleFromEyes + CHIN_WEIGHT * scaleFromChin;
      scale = Math.max(scaleFromEyes * 0.75, Math.min(scaleFromEyes * 1.25, blended));
    }

    // We store Before's target inter-eye pixel span in the output.
    // After recomputes its scale to match that exact span.
    // Rotation is NOT locked — each photo keeps its own tilt correction
    // so facial features align naturally to their own pose.
    let finalScale = scale;
    let finalAngle = angle;
    const targetInterEyePixels = scale * interEyeDist;

    if (slot === "before") {
      beforeFramingRef.current = { targetInterEyePixels };
    } else if (slot === "after" && lockFraming && beforeFramingRef.current) {
      finalScale = beforeFramingRef.current.targetInterEyePixels / interEyeDist;
      // finalAngle stays as After's own correction — better alignment
    }

    if (img.width < sz || img.height < sz) {
      slotWarnings.push(`Source ${img.width}×${img.height} smaller than output ${sz}px — may appear blurry`);
      setWarnings((prev) => ({ ...prev, [slot]: slotWarnings }));
    }

    const tX = sz / 2, tY = sz * EYE_Y_RATIO;

    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, sz, sz);
    ctx.save();
    ctx.translate(tX, tY);
    ctx.scale(finalScale, finalScale);
    ctx.rotate(-finalAngle);
    ctx.translate(-eyeCX, -eyeCY);
    ctx.drawImage(img, 0, 0);
    ctx.restore();

    if (showGuides) {
      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 1;
      ctx.setLineDash([8, 8]);
      ctx.beginPath(); ctx.moveTo(0, tY); ctx.lineTo(sz, tY); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(tX, 0); ctx.lineTo(tX, sz); ctx.stroke();
      if (scaleMode === "aesthetic") {
        ctx.strokeStyle = "rgba(200,169,126,0.2)";
        const chinY = sz * CHIN_Y_RATIO;
        ctx.beginPath(); ctx.moveTo(0, chinY); ctx.lineTo(sz, chinY); ctx.stroke();
      }
      ctx.strokeStyle = "rgba(255,255,255,0.12)";
      [1 / 3, 2 / 3].forEach((r) => {
        ctx.beginPath(); ctx.moveTo(0, sz * r); ctx.lineTo(sz, sz * r); ctx.stroke();
      });
      ctx.restore();
    }

    setResults((prev) => ({ ...prev, [slot]: canvas.toDataURL(`image/${exportFormat}`, 0.95) }));
  }, [outputSize, bgColor, showGuides, exportFormat, scaleMode, lockFraming]);

  const processImageFromPreview = useCallback((slot, previewLm) => {
    const img = imgRefs[slot].current;
    if (!img || !previewLm) return;
    processImageFromOriginal(slot, scaleFromPreview(previewLm, previewScale(img)), img);
  }, [processImageFromOriginal]);

  const handleDrop = useCallback(async (slot, e) => {
    e.preventDefault();
    e.stopPropagation();
    const file = e.dataTransfer ? e.dataTransfer.files[0] : (e.target ? e.target.files[0] : null);
    if (!file || !file.type.startsWith("image/")) return;
    if (e.target && e.target.value) e.target.value = "";

    const img = await loadImage(file);
    imgRefs[slot].current = img;

    if (objectUrlsRef.current[slot]) URL.revokeObjectURL(objectUrlsRef.current[slot]);
    const newUrl = URL.createObjectURL(file);
    objectUrlsRef.current[slot] = newUrl;

    setImages((p) => ({ ...p, [slot]: newUrl }));
    setResults((p) => ({ ...p, [slot]: null }));
    setLandmarks((p) => ({ ...p, [slot]: null }));
    setDetectionStatus((p) => ({ ...p, [slot]: null }));
    setManualMode((p) => ({ ...p, [slot]: false }));

    if (autoDetect && modelReady) {
      setDetectionStatus((p) => ({ ...p, [slot]: "detecting" }));
      setProcessing(true);
      try {
        const detected = await detectFace(img);
        if (detected) {
          const scaled = scaleToPreview(detected, previewScale(img));
          setLandmarks((p) => ({ ...p, [slot]: scaled }));
          setDetectionStatus((p) => ({ ...p, [slot]: "success" }));
          processImageFromOriginal(slot, detected, img);
        } else {
          setDetectionStatus((p) => ({ ...p, [slot]: "failed" }));
        }
      } catch(err) {
        setDetectionStatus((p) => ({ ...p, [slot]: "failed" }));
      }
      setProcessing(false);
    }
  }, [autoDetect, modelReady, detectFace, processImageFromOriginal]);

  const startManualPlacement = useCallback((slot) => {
    setActiveSlot(slot);
    setClickStep("leftEye");
    tempPointsRef.current = {};
    setTempPointsVer((v) => v + 1);
    setManualMode((p) => ({ ...p, [slot]: true }));
    setDetectionStatus((p) => ({ ...p, [slot]: null }));
    setResults((p) => ({ ...p, [slot]: null }));
    setLandmarks((p) => ({ ...p, [slot]: null }));
  }, []);

  const handleCanvasClick = useCallback((slot, e) => {
    const canvas = e.currentTarget;
    const rect = canvas.getBoundingClientRect();
    const sX = canvas.width / rect.width;
    const sY = canvas.height / rect.height;
    const x = (e.clientX - rect.left) * sX;
    const y = (e.clientY - rect.top) * sY;

    setClickStep((currentStep) => {
      if (currentStep === "leftEye") {
        tempPointsRef.current = { ...tempPointsRef.current, leftEye: { x, y } };
        setTempPointsVer((v) => v + 1);
        return "rightEye";
      } else if (currentStep === "rightEye") {
        tempPointsRef.current = { ...tempPointsRef.current, rightEye: { x, y } };
        setTempPointsVer((v) => v + 1);
        return "chin";
      } else if (currentStep === "chin") {
        const pts = { ...tempPointsRef.current, chin: { x, y } };
        tempPointsRef.current = {};
        setTempPointsVer((v) => v + 1);
        setLandmarks((p) => ({ ...p, [slot]: pts }));
        setActiveSlot(null);
        setManualMode((p) => ({ ...p, [slot]: false }));
        setDetectionStatus((p) => ({ ...p, [slot]: "manual" }));
        return null;
      }
      return currentStep;
    });
  }, []);

  useEffect(() => {
    ["before", "after"].forEach((slot) => {
      if (landmarks[slot]) processImageFromPreview(slot, landmarks[slot]);
    });
  }, [landmarks, processImageFromPreview]);

  useEffect(() => {
    if (lockFraming && landmarks.before && landmarks.after) {
      processImageFromPreview("after", landmarks.after);
    }
  }, [landmarks.before, lockFraming]);

  useEffect(() => {
    ["before", "after"].forEach((slot) => {
      if (landmarks[slot]) processImageFromPreview(slot, landmarks[slot]);
    });
  }, [outputSize, bgColor, showGuides, exportFormat, scaleMode, lockFraming, processImageFromPreview]);

  const drawPreview = useCallback((slot) => {
    const canvas = previewRefs[slot].current;
    const img = imgRefs[slot].current;
    if (!canvas || !img) return;
    const ctx = canvas.getContext("2d");
    const s = previewScale(img);
    canvas.width = img.width * s;
    canvas.height = img.height * s;
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    const pts = landmarks[slot] || tempPointsRef.current;
    const drawPt = (pt, label, color) => {
      if (!pt) return;
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, 5, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 1.5;
      ctx.stroke();
      if (label) {
        ctx.fillStyle = "#fff";
        ctx.font = "bold 10px sans-serif";
        ctx.fillText(label, pt.x + 8, pt.y - 4);
      }
    };
    if (pts.leftEye && pts.rightEye) {
      ctx.beginPath();
      ctx.moveTo(pts.leftEye.x, pts.leftEye.y);
      ctx.lineTo(pts.rightEye.x, pts.rightEye.y);
      ctx.strokeStyle = "rgba(200,169,126,0.5)";
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    drawPt(pts.leftEye, "L", "#4ecdc4");
    drawPt(pts.rightEye, "R", "#ff6b6b");
    drawPt(pts.chin, "C", "#c8a97e");
  }, [landmarks, tempPointsVer]);

  useEffect(() => {
    ["before", "after"].forEach((slot) => {
      if (images[slot] && imgRefs[slot].current) drawPreview(slot);
    });
  }, [images, landmarks, tempPointsVer, drawPreview]);

  const retryDetection = useCallback(async (slot) => {
    const img = imgRefs[slot].current;
    if (!img || !modelReady) return;
    setDetectionStatus((p) => ({ ...p, [slot]: "detecting" }));
    setProcessing(true);
    try {
      const detected = await detectFace(img);
      if (detected) {
        const scaled = scaleToPreview(detected, previewScale(img));
        setLandmarks((p) => ({ ...p, [slot]: scaled }));
        setDetectionStatus((p) => ({ ...p, [slot]: "success" }));
        processImageFromOriginal(slot, detected, img);
      } else {
        setDetectionStatus((p) => ({ ...p, [slot]: "failed" }));
      }
    } catch(err) {
      setDetectionStatus((p) => ({ ...p, [slot]: "failed" }));
    }
    setProcessing(false);
  }, [modelReady, detectFace, processImageFromOriginal]);

  const downloadResult = useCallback((slot) => {
    if (!results[slot]) return;
    const a = document.createElement("a");
    a.href = results[slot];
    a.download = `beauty-spot-${slot}-standardized.${exportFormat}`;
    a.click();
  }, [results, exportFormat]);

  const downloadBoth = useCallback(() => {
    downloadResult("before");
    setTimeout(() => downloadResult("after"), 500);
  }, [downloadResult]);

  const downloadComposite = useCallback(() => {
    if (!results.before || !results.after) return;
    const c = document.createElement("canvas");
    c.width = outputSize * 2 + 32;
    c.height = outputSize + 80;
    const ctx = c.getContext("2d");
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, c.width, c.height);
    const iB = new Image(), iA = new Image();
    let n = 0;
    const done = () => {
      if (++n < 2) return;
      ctx.drawImage(iB, 0, 40, outputSize, outputSize);
      ctx.drawImage(iA, outputSize + 32, 40, outputSize, outputSize);
      ctx.fillStyle = "#1a1714";
      ctx.font = "bold 14px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("BEFORE", outputSize / 2, 26);
      ctx.fillText("AFTER", outputSize + 32 + outputSize / 2, 26);
      ctx.font = "10px sans-serif";
      ctx.fillStyle = "#8a7d6d";
      ctx.fillText("Beauty Spot Clinic · No Filter Just You", c.width / 2, c.height - 12);
      const a = document.createElement("a");
      a.href = c.toDataURL(`image/${exportFormat}`, 0.95);
      a.download = `beauty-spot-comparison.${exportFormat}`;
      a.click();
    };
    iB.onload = done; iA.onload = done;
    iB.src = results.before; iA.src = results.after;
  }, [results, outputSize, bgColor, exportFormat]);

  const resetSlot = useCallback((slot) => {
    if (objectUrlsRef.current[slot]) {
      URL.revokeObjectURL(objectUrlsRef.current[slot]);
      objectUrlsRef.current[slot] = null;
    }
    setImages((p) => ({ ...p, [slot]: null }));
    setResults((p) => ({ ...p, [slot]: null }));
    setLandmarks((p) => ({ ...p, [slot]: null }));
    setDetectionStatus((p) => ({ ...p, [slot]: null }));
    setManualMode((p) => ({ ...p, [slot]: false }));
    imgRefs[slot].current = null;
  }, []);

  const swapSlots = useCallback(() => {
    const swap = (prev) => ({ before: prev.after, after: prev.before });
    setImages(swap);
    setResults(swap);
    setLandmarks(swap);
    setDetectionStatus(swap);
    setManualMode(swap);
    setWarnings(swap);
    const tmpImg = imgRefs.before.current;
    imgRefs.before.current = imgRefs.after.current;
    imgRefs.after.current = tmpImg;
    const tmpUrl = objectUrlsRef.current.before;
    objectUrlsRef.current.before = objectUrlsRef.current.after;
    objectUrlsRef.current.after = tmpUrl;
    beforeFramingRef.current = null;
  }, []);

  const flipImage = useCallback(async (slot) => {
    const img = imgRefs[slot].current;
    if (!img) return;
    const c = document.createElement("canvas");
    c.width = img.width;
    c.height = img.height;
    const ctx = c.getContext("2d");
    ctx.translate(img.width, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(img, 0, 0);
    const blob = await new Promise((res) => c.toBlob(res, "image/png"));
    const url = URL.createObjectURL(blob);
    const flipped = await new Promise((resolve) => {
      const newImg = new Image();
      newImg.onload = () => { URL.revokeObjectURL(url); resolve(newImg); };
      newImg.src = url;
    });
    imgRefs[slot].current = flipped;
    setLandmarks((p) => ({ ...p, [slot]: null }));
    setResults((p) => ({ ...p, [slot]: null }));
    setDetectionStatus((p) => ({ ...p, [slot]: null }));
    setWarnings((p) => ({ ...p, [slot]: [] }));
    if (autoDetect && modelReady) {
      setDetectionStatus((p) => ({ ...p, [slot]: "detecting" }));
      setProcessing(true);
      try {
        const detected = await detectFace(flipped);
        if (detected) {
          const scaled = scaleToPreview(detected, previewScale(flipped));
          setLandmarks((p) => ({ ...p, [slot]: scaled }));
          setDetectionStatus((p) => ({ ...p, [slot]: "success" }));
          processImageFromOriginal(slot, detected, flipped);
        } else {
          setDetectionStatus((p) => ({ ...p, [slot]: "failed" }));
        }
      } catch(err) {
        setDetectionStatus((p) => ({ ...p, [slot]: "failed" }));
      }
      setProcessing(false);
    }
    setTempPointsVer((v) => v + 1);
  }, [autoDetect, modelReady, detectFace, processImageFromOriginal]);

  const stepLabel =
    clickStep === "leftEye" ? "① Click LEFT eye center" :
    clickStep === "rightEye" ? "② Click RIGHT eye center" :
    clickStep === "chin" ? "③ Click CHIN tip" : "";

  return (
    <div style={S.app}>
      <div style={S.ambientGlow} />

      <header style={S.header}>
        <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
          <div style={S.logoMark}>
            <svg width="26" height="26" viewBox="0 0 24 24" fill="none" stroke="#c8a97e" strokeWidth="1.8" strokeLinecap="round">
              <circle cx="12" cy="8" r="5" /><path d="M3 21c0-4.97 4.03-9 9-9s9 4.03 9 9" />
              <circle cx="9.5" cy="7" r="0.8" fill="#c8a97e" stroke="none" /><circle cx="14.5" cy="7" r="0.8" fill="#c8a97e" stroke="none" />
            </svg>
          </div>
          <div>
            <h1 style={{ margin: 0, fontSize: 20, fontWeight: 700, color: "#c8a97e", letterSpacing: "-0.3px" }}>Face Standardizer</h1>
            <p style={{ margin: 0, fontSize: 10, color: "#6a5f52", letterSpacing: "2px", textTransform: "uppercase" }}>Beauty Spot Clinic</p>
          </div>
        </div>
        <div style={{ display: "flex", alignItems: "center", gap: 16, fontSize: 12 }}>
          <span style={S.privacyBadge}>
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round"><rect x="3" y="11" width="18" height="11" rx="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
            Photos never leave your device
          </span>
          {modelLoading ? <span style={{ color: "#c8a97e", animation: "pulse 1.5s ease-in-out infinite" }}>⟳ Loading AI...</span> :
           modelReady ? <span style={{ color: "#4ecdc4" }}>● MediaPipe Ready</span> :
           <span style={{ color: "#ff6b6b" }}>○ Model unavailable</span>}
        </div>
      </header>

      <div style={S.toolbar}>
        <div style={{ display: "flex", gap: 16, alignItems: "center", flexWrap: "wrap" }}>
          <label style={S.ctrlLabel}>Output
            <select value={outputSize} onChange={(e) => setOutputSize(Number(e.target.value))} style={S.select}>
              <option value={256}>256px</option><option value={512}>512px</option><option value={768}>768px</option><option value={1024}>1024px</option>
            </select>
          </label>
          <label style={S.ctrlLabel}>BG
            <input type="color" value={bgColor} onChange={(e) => setBgColor(e.target.value)} style={S.colorPicker} />
          </label>
          <label style={S.ctrlLabel}>Format
            <select value={exportFormat} onChange={(e) => setExportFormat(e.target.value)} style={S.select}>
              <option value="png">PNG</option><option value="jpeg">JPEG</option><option value="webp">WebP</option>
            </select>
          </label>
          <label style={S.ctrlLabel}>Scale
            <select value={scaleMode} onChange={(e) => setScaleMode(e.target.value)} style={S.select}>
              <option value="aesthetic">Aesthetic</option><option value="strict">Strict IPD</option>
            </select>
          </label>
        </div>
        <div style={{ display: "flex", gap: 16, alignItems: "center" }}>
          {[["Guides", showGuides, setShowGuides], ["Auto-detect", autoDetect, setAutoDetect], ["Lock framing", lockFraming, setLockFraming]].map(([label, val, setter]) => (
            <label key={label} style={{ display: "flex", alignItems: "center", gap: 8, cursor: "pointer" }}>
              <span style={{ fontSize: 11, color: "#6a5f52", textTransform: "uppercase", letterSpacing: "0.5px" }}>{label}</span>
              <div
                style={{ width: 36, height: 18, borderRadius: 9, background: val ? "rgba(78,205,196,0.3)" : "rgba(255,255,255,0.1)", position: "relative", cursor: "pointer", transition: "background 0.2s" }}
                onClick={() => setter(!val)}
              >
                <div style={{ width: 14, height: 14, borderRadius: 7, position: "absolute", top: 2, background: val ? "#4ecdc4" : "#666", transition: "all 0.2s", transform: val ? "translateX(18px)" : "translateX(2px)" }} />
              </div>
            </label>
          ))}
        </div>
      </div>

      {processing && (
        <div style={S.processingOverlay}>
          <div style={S.processingBar}><div style={S.processingFill} /></div>
          <span style={S.processingText}>Detecting face...</span>
        </div>
      )}

      <div style={S.steps}>
        {[["1", "Upload photos"], ["2", "AI detects landmarks"], ["3", "Download standardized"]].map(([n, t], i) => (
          <div key={n} style={{ display: "flex", alignItems: "center", gap: 6 }}>
            {i > 0 && <span style={{ color: "#3a3530", fontSize: 16, marginRight: 6 }}>→</span>}
            <span style={S.stepCircle}>{n}</span>
            <span style={{ fontSize: 12, color: "#8a7d6d" }}>{t}</span>
          </div>
        ))}
      </div>

      <div style={S.grid}>
        <SlotPanel
          key="before"
          slot="before"
          label="Before"
          image={images.before}
          result={results.before}
          detectionStatus={detectionStatus.before}
          isManual={manualMode.before}
          activeSlot={activeSlot}
          hasLandmarks={!!landmarks.before}
          processing={processing}
          modelReady={modelReady}
          outputSize={outputSize}
          stepLabel={stepLabel}
          onReset={resetSlot}
          onDrop={handleDrop}
          onRetry={retryDetection}
          onManualStart={startManualPlacement}
          onDownload={downloadResult}
          onFlip={flipImage}
          fileRef={fileRefs.before}
          previewRef={previewRefs.before}
          canvasRef={canvasRefs.before}
          onCanvasClick={handleCanvasClick}
          ghostImage={null}
          slotWarnings={warnings.before}
        />
        <div style={S.swapColumn}>
          <button onClick={swapSlots} style={S.swapBtn} title="Swap Before ↔ After" disabled={processing}>
            ⇄
          </button>
        </div>
        <SlotPanel
          key="after"
          slot="after"
          label="After"
          image={images.after}
          result={results.after}
          detectionStatus={detectionStatus.after}
          isManual={manualMode.after}
          activeSlot={activeSlot}
          hasLandmarks={!!landmarks.after}
          processing={processing}
          modelReady={modelReady}
          outputSize={outputSize}
          stepLabel={stepLabel}
          onReset={resetSlot}
          onDrop={handleDrop}
          onRetry={retryDetection}
          onManualStart={startManualPlacement}
          onDownload={downloadResult}
          onFlip={flipImage}
          fileRef={fileRefs.after}
          previewRef={previewRefs.after}
          canvasRef={canvasRefs.after}
          onCanvasClick={handleCanvasClick}
          ghostImage={manualMode.after ? results.before : null}
          slotWarnings={warnings.after}
        />
      </div>

      {results.before && results.after && (
        <div style={S.bottomActions}>
          <button onClick={() => setCompareMode(!compareMode)} style={S.compareBtn}>
            {compareMode ? "✕ Hide" : "⬌"} Comparison
          </button>
          <button onClick={downloadBoth} style={S.dlAllBtn}>↓ Download Both</button>
        </div>
      )}

      {compareMode && results.before && results.after && (
        <AdvancedComparison
          before={results.before}
          after={results.after}
          onDownload={downloadComposite}
        />
      )}

      <footer style={S.footer}>
        <p style={{ color: "#3a3530", fontSize: 11, letterSpacing: "1px" }}>Beauty Spot Clinic · Aesthetic Medicine · Jerusalem</p>
        <p style={{ color: "#2a2520", fontSize: 10, marginTop: 4 }}>
          {scaleMode === "strict" ? "Strict IPD scaling" : "Aesthetic chin-stabilized scaling"}
          {lockFraming ? " · Framing locked" : ""} · Proportions preserved
        </p>
      </footer>
    </div>
  );
};

const S = {
  app: { fontFamily: "'DM Sans', sans-serif", background: "#111010", minHeight: "100vh", color: "#e8e0d4", position: "relative", overflow: "hidden" },
  ambientGlow: { position: "fixed", top: "-30%", left: "50%", transform: "translateX(-50%)", width: "120%", height: "60%", background: "radial-gradient(ellipse, rgba(200,169,126,0.04) 0%, transparent 70%)", pointerEvents: "none", zIndex: 0 },
  header: { position: "relative", zIndex: 1, display: "flex", justifyContent: "space-between", alignItems: "center", padding: "18px 28px", borderBottom: "1px solid rgba(200,169,126,0.1)", background: "rgba(17,16,16,0.8)", backdropFilter: "blur(20px)", flexWrap: "wrap", gap: 12 },
  logoMark: { width: 44, height: 44, borderRadius: 12, background: "rgba(200,169,126,0.08)", display: "flex", alignItems: "center", justifyContent: "center", border: "1px solid rgba(200,169,126,0.15)" },
  toolbar: { position: "relative", zIndex: 1, display: "flex", justifyContent: "space-between", alignItems: "center", padding: "10px 28px", borderBottom: "1px solid rgba(200,169,126,0.06)", background: "rgba(17,16,16,0.5)", flexWrap: "wrap", gap: 12 },
  ctrlLabel: { fontSize: 11, color: "#6a5f52", textTransform: "uppercase", letterSpacing: "0.5px", display: "flex", alignItems: "center", gap: 8 },
  select: { background: "rgba(255,255,255,0.05)", border: "1px solid rgba(200,169,126,0.15)", borderRadius: 6, color: "#e8e0d4", padding: "5px 10px", fontSize: 12, outline: "none" },
  colorPicker: { width: 26, height: 26, border: "1px solid rgba(200,169,126,0.15)", borderRadius: 6, cursor: "pointer", background: "transparent", padding: 0 },
  processingOverlay: { position: "relative", zIndex: 2, background: "rgba(17,16,16,0.85)", backdropFilter: "blur(4px)", padding: "8px 28px", display: "flex", alignItems: "center", gap: 12 },
  processingBar: { flex: 1, height: 2, background: "rgba(200,169,126,0.08)", overflow: "hidden", borderRadius: 1 },
  processingFill: { height: "100%", width: "30%", background: "linear-gradient(90deg, transparent, #c8a97e, transparent)", animation: "slide 1s ease-in-out infinite" },
  processingText: { fontSize: 11, color: "#c8a97e", whiteSpace: "nowrap", fontWeight: 500 },
  steps: { position: "relative", zIndex: 1, display: "flex", alignItems: "center", justifyContent: "center", gap: 12, padding: "16px 28px", flexWrap: "wrap" },
  stepCircle: { width: 22, height: 22, borderRadius: 11, background: "rgba(200,169,126,0.12)", color: "#c8a97e", display: "inline-flex", alignItems: "center", justifyContent: "center", fontSize: 11, fontWeight: 700, flexShrink: 0 },
  grid: { position: "relative", zIndex: 1, display: "grid", gridTemplateColumns: "1fr auto 1fr", gap: 12, padding: "12px 28px", maxWidth: 1140, margin: "0 auto", alignItems: "start" },
  swapColumn: { display: "flex", alignItems: "center", justifyContent: "center", paddingTop: 120 },
  swapBtn: { background: "rgba(255,255,255,0.05)", border: "1px solid rgba(200,169,126,0.2)", color: "#c8a97e", borderRadius: "50%", width: 36, height: 36, display: "flex", alignItems: "center", justifyContent: "center", cursor: "pointer", fontSize: 18, transition: "all 0.2s", flexShrink: 0 },
  privacyBadge: { display: "flex", alignItems: "center", gap: 6, fontSize: 10, color: "#4ecdc4", background: "rgba(78,205,196,0.08)", border: "1px solid rgba(78,205,196,0.15)", borderRadius: 6, padding: "4px 10px", letterSpacing: "0.3px", whiteSpace: "nowrap" },
  ghostOverlay: { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", pointerEvents: "none", opacity: 0.25, mixBlendMode: "difference", borderRadius: 8, overflow: "hidden" },
  ghostImg: { width: "100%", height: "100%", objectFit: "contain" },
  ghostLabel: { position: "absolute", top: 6, right: 6, background: "rgba(200,169,126,0.8)", color: "#1a1714", padding: "2px 8px", borderRadius: 4, fontSize: 9, fontWeight: 700, letterSpacing: "0.5px" },
  panel: { background: "rgba(255,255,255,0.02)", borderRadius: 14, border: "1px solid rgba(200,169,126,0.08)", overflow: "hidden" },
  panelHead: { display: "flex", justifyContent: "space-between", alignItems: "center", padding: "12px 16px", borderBottom: "1px solid rgba(200,169,126,0.06)" },
  panelLabel: { fontSize: 11, fontWeight: 700, textTransform: "uppercase", letterSpacing: "2px", color: "#c8a97e" },
  resetBtn: { background: "none", border: "none", color: "#5a5045", cursor: "pointer", fontSize: 13, padding: "4px 8px" },
  dropzone: { padding: "40px 20px", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", cursor: "pointer", minHeight: 200, border: "2px dashed rgba(200,169,126,0.15)", margin: 12, borderRadius: 10, transition: "all 0.3s" },
  previewCanvas: { maxWidth: "100%", maxHeight: "100%", borderRadius: 8, border: "1px solid rgba(200,169,126,0.08)", objectFit: "contain" },
  previewContainer: { position: "relative", textAlign: "center", height: 280, display: "flex", alignItems: "center", justifyContent: "center", overflow: "hidden" },
  stepBadge: { position: "absolute", bottom: 10, left: "50%", transform: "translateX(-50%)", background: "rgba(200,169,126,0.95)", color: "#1a1714", padding: "7px 16px", borderRadius: 20, fontSize: 12, fontWeight: 700, whiteSpace: "nowrap" },
  actionRow: { display: "flex", gap: 8, marginTop: 10, justifyContent: "center", flexWrap: "wrap" },
  actionBtn: { background: "rgba(255,255,255,0.04)", border: "1px solid rgba(200,169,126,0.2)", color: "#a89880", borderRadius: 8, padding: "7px 16px", fontSize: 12, cursor: "pointer", fontWeight: 500, transition: "all 0.2s" },
  resultImg: { maxWidth: "100%", borderRadius: 8, border: "1px solid rgba(200,169,126,0.1)", boxShadow: "0 12px 40px rgba(0,0,0,0.4)" },
  dlBtn: { marginTop: 10, background: "linear-gradient(135deg, #c8a97e, #a8895e)", border: "none", color: "#1a1714", borderRadius: 8, padding: "9px 22px", fontSize: 12, fontWeight: 700, cursor: "pointer", boxShadow: "0 4px 12px rgba(200,169,126,0.2)" },
  bottomActions: { position: "relative", zIndex: 1, display: "flex", justifyContent: "center", gap: 12, padding: "12px 28px 0" },
  compareBtn: { background: "rgba(255,255,255,0.04)", border: "1px solid rgba(200,169,126,0.2)", color: "#c8a97e", borderRadius: 10, padding: "11px 24px", fontSize: 13, fontWeight: 500, cursor: "pointer" },
  dlAllBtn: { background: "linear-gradient(135deg, #c8a97e, #a8895e)", border: "none", color: "#1a1714", borderRadius: 10, padding: "11px 24px", fontSize: 13, fontWeight: 700, cursor: "pointer", boxShadow: "0 4px 16px rgba(200,169,126,0.2)" },
  footer: { position: "relative", zIndex: 1, textAlign: "center", padding: 28 },
  warningsBox: { marginTop: 6, display: "flex", flexDirection: "column", gap: 3 },
  warningItem: { fontSize: 11, color: "#e8a838", background: "rgba(232,168,56,0.08)", border: "1px solid rgba(232,168,56,0.15)", borderRadius: 6, padding: "4px 10px" },
};

ReactDOM.render(<FaceStandardizer />, document.getElementById("root"));
</script>
</body>
</html>